# 深拷贝和浅拷贝

在项目中初次碰到深拷贝和浅拷贝的问题场景是这样的：一个数据注册的信息初始化模板（注册字段比较多），在初始化页面是需要拷贝这个信息模板来初始化页面，本来复制一下是没什么的，但鉴于中间某些操作需要再次使用该信息模板，但因为之前拷贝后对部分值做了修改，导致原信息模板值也同时发生了改变，这才发现拷贝是存在深拷贝和浅拷贝的区别的。

## 深拷贝和浅拷贝的区别在哪里呢？

在介绍深浅拷贝的区别之前，我们先讲解几个前置概念，方便我们更好的理解深浅拷贝的差异。

### 一、数据类型的分类

js的数据类型大体分为两类：
```
1、基础数据类型：Number,String,Undefined,Null,Boolean,Symbol。这些类型的数据可以直接操作保存在变量中的实际值。
2、引用数据类型：Object，Array,Function，可以说除了基础数据类型之外的都属于引用数据类型。
```

### 二、栈和堆

栈会自动分配内存空间，且会自动释放，它的空间大小是固定的，一般用来存放基础数据类型，简单的数据段。

堆是动态分配的内存空间，大小不固定且不会自动释放。一般用来存放引用数据类型。

我们看下面的一个例子:
```
let a = [1, 2, 3, 4, 5]
let b = a;
let c = a[0];
b[1] = 100;
c = 20;
console.log(a);  //[1,100,3,4,5]
```
结合上例打印结果可知：a是一个数组，属于引用数据类型，将其赋值给b，实际上是将其引用地址拷贝一份传给了b并存放到栈中，而真实的数组对象则是存放在堆中，系统通过引用地址（或者说指针）来快速查找保存到堆内存中的对象，所以修改数组b就等同于修原数组a。而c只是从a的堆内存中获取了几个基础类型数据拷贝给a,然后将该备份存放到栈内存中，此时该备份与原数据是相互独立的个体，修改c将直接修改栈内存中的值，与a无关。

总的来说就是：简单数据类型直接储存在栈内存中，可以直接访问并对其进行修改；而引用数据类型则是存放在堆内存中，保存在栈内存中的变量其实是一个引用地址（或者说指针）,该指针指向堆内存中存放的对象数据，可以通过指针来查找保存在堆内存中的对象。而拷贝引用数据类型就是拷贝指针，因为拷贝后的指针指向的是同一个对象，所以修改任何一个变量都会修改堆内存中的对象。


如果上述语言过于文字化，我们再举个例子：栈内存就好比一个书橱，每个格子里面存放一本书（也就是基础类型数据），我们要拷贝一份就好比重新印刷一本然后放到下一个空格子里面，二者相互独立，互不相干。堆内存就好比一个大仓库，这些仓库又分许多区，区的大小不一致，每个区都存放某一类书籍，数量不固定，种类不固定(好比引用数据类型的对象和或数组，大小不确定)。为了给对应的区进行分类，我们给每个区一个编号球，然后将编号球放在书橱里，想去查找仓库某个区的书籍时就通过编号快速查询。而拷贝引用数据类型，鉴于其占用内存的大小说不准，为了节约空间，我们就把其编号球复制一个，放到新的书格子里，这样因为他们对应共同的区编号，都可以找到并查看区里的书籍。这样是不是就很好理解了？

讲了上面2个概念，我们再回头来看深拷贝和浅拷贝，就不会显得没有头绪了。

所谓浅拷贝就是仅仅拷贝基本数据类型，而对于引用数据类型，因为拷贝的只是其引用地址，拷贝后的引用类型数据源发生改变，就意味着原数据源也同时发生了改变。

而深拷贝就是拷贝之后相当于重新开辟出一个内存空间来存放复制的对象，二者相互独立，内容相同但各自占用一个独立内存空间。

## 常见的浅拷贝方法

### 1、slice

大家知道slice()方法可以用来操作一个数组从中截取一段数据形成一个新数组返回。如果不传值，则相当于复制了一个相同的数组并返回。如下所示：
```
let a = [1,2,3,4,5];
let b = a.slice();
b[0] = 100;
console.log(a); //[1,2,3,4,5]
```

### 2、concat

concat()也是数组的一个处理方法，用于将两个或多个数组拼接为一个新的数组并返回，而不会改变原数组。如下所示：

```
let a = [1,2,3,4,5];
let b = a.concat();
b[0] = 100;
console.log(a); //[1,2,3,4,5]
```

### 3、遍历数组的各项元素，组成一个新数组，这个就不做详述。

备注：以上方法都是数组的拷贝，下面2个是对象的拷贝。

### 4、Object.assign()

Object.assign()方法用于合并对象，即将所有可枚举属性的值从一个或多个源对象复制到目标对象，最终返回目标对象。

如果源对象中有和目标对象同名的属性，则后者会覆盖前者，例如：
```
const o1 = { a: 1, b: 1, c: 1 };
const o2 = { b: 2, c: 2 };
const o3 = { c: 3 };

const obj = Object.assign({}, o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
```

但鉴于Object.assign()拷贝时拷贝的是属性值，假如源对象的属性值是一个对象的引用，那么它只能指向那个引用。所以它不能实现深拷贝。

### 5、扩展运算符

扩展运算符可以在函数调用和数组构造时，将数组表达式和string在语法层面上展开，或将对象以key-value的形式展开来。

```
//示例一
let a = [1,2,3];
function add(x,y,z){
  return x+y+z
}
console.log(add(...a)); //6

//示例二
let c = [...a];  //也可以实现数组的复制
let d = {...{a:1,b:2}}  //可以实现对象的复制
```
但如果上述数组和对象中的属性包含其他数组或对象时，这时候复制的依旧是其对应引用地址，所以也无法实现深拷贝。


## 如何实现深拷贝？

1、最通用的方法就是下面这种：
```
JSON.parse(JSON.stringify(obj))
```
该方法可以轻松的实现深拷贝。
2、鉴于上面列举的方法无法实现深拷贝的原因是对于引用类型的数据无法直接拷贝值而是拷贝其引用地址，那么我们对每个引用类型的数据做层层循环遍历处理，也可以达到深拷贝的目的，以下是网上提供的方法：

```
function copy (obj) {
    var newobj = obj.constructor === Array ? [] : {};
    if(typeof obj !== 'object'){
        return;
    }
    for(var i in obj){
        newobj[i] = typeof obj[i] === 'object' ?
        copy(obj[i]) : obj[i];
    }
    return newobj
}

```

## 总结

最后我们要知道：深拷贝实际上是很耗性能的，因为它将会把原对象的内容进行复制然后开辟出一块全新的内存空间来进行存放，这样如果对象数据量大而拷贝次数过多，对性能就会产生影响。